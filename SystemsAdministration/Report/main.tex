\documentclass[a4page]{article}
\usepackage[14pt]{extsizes} % для того чтобы задать нестандартный 14-ый размер шрифта
\usepackage[utf8]{inputenc}
\usepackage[T1, T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel} % поддержка русского языка
\usepackage{amsmath}  %  математические символы
\usepackage[left=20mm, top=15mm, right=15mm, bottom=30mm, footskip=15mm]{geometry} % настройки полей документа
\usepackage{indentfirst} % по умалчанию убирается отступ у первого абзаца в секции, это отменяет это.
\usepackage{paralist} % добавить компактные списки (compactitem, compactenum, compactdesc)

\usepackage{fancyvrb}
\usepackage{framed}
\usepackage{url}

\usepackage{float}
\floatstyle{ruled}

\usepackage{csquotes}

\usepackage[
	backend=biber,
	sorting=nyt,
	bibstyle=gost-numeric,
	citestyle=gost-numeric
]{biblatex}

\usepackage[
	bookmarks=true, colorlinks=true, unicode=true,
	%urlcolor=black,linkcolor=black, anchorcolor=black,
	%citecolor=black, menucolor=black, filecolor=black,
]{hyperref}

\addbibresource{sources.bib}

\renewcommand{\baselinestretch}{1.35}

\begin{document} % начало документа


% НАЧАЛО ТИТУЛЬНОГО ЛИСТА
\begin{titlepage}

	\begin{center}
		\hfill \break
		\textbf{
			\large{РОССИЙСКИЙ УНИВЕРСИТЕТ ДРУЖБЫ НАРОДОВ}\\
			\normalsize{Факультет физико-математических и естественных наук}\\
			\normalsize{Кафедра прикладной информатики и теории вероятностей}\\
		}
		\vspace*{\fill}
		\Large{\textbf{ДОКЛАД\\ на тему <<Логические тома ZFS>>}}
		\\
		\underline{\textit{\normalsize{Дисциплина: Основы администрирования операционных систем}}}
		\vspace*{\fill}

	\end{center}

	\begin{flushright}
		Студент: \underline{Матюхин Григорий}\\ \vspace{0.5cm}
		Группа: \underline{НПИбд-01-21}
	\end{flushright}


	\begin{center} \textbf{МОСКВА} \\ 2022 г. \end{center}
	\thispagestyle{empty} % выключаем отображение номера для этой страницы

\end{titlepage}
% КОНЕЦ ТИТУЛЬНОГО ЛИСТА

\newpage

\tableofcontents

\newpage

\section{Введение}

ZFS (изначально Zettabyte File System) — copy-on-write файловая система с деревом Меркла,
созданная Sun Microsystems в 2004–2005 годах для операционной системы Solaris.
Эта файловая система поддерживает большие объёмы данных,
объединяет концепции файловой системы, массивов RAID и менеджера логических дисков (томов).

Основные преимущества ZFS — это её полный контроль над физическими носителями и логическими томами
и постоянное поддержание консистентности файловой системы.
Оперируя на разных уровнях абстракции данных, ZFS способна обеспечить высокую скорость доступа к ним,
контроль их целостности, а также минимизацию фрагментации данных.

ZFS позволяет в процессе работы изменять объём дискового пространства
и задавать разный размер блоков данных для разных применений,
обеспечивает параллельность выполнения операций чтения-записи.

\section{Пулы хранения}

В отличие от традиционных файловых систем, которые располагаются на одном устройстве и,
при использовании более чем на одном устройстве для которых требуется менеджер томов,
ZFS строится поверх виртуальных пулов хранения данных, называемых \texttt{zpool}.
Пул построен из виртуальных устройств (\texttt{vdevs}),
каждое из которых является либо физическим устройством,
либо зеркалом дного или нескольких устройств,
либо --- группой из двух или более устройств.
Ёмкость всех \texttt{vdevs} затем доступна для всех файловых систем в \texttt{zpool}.

Для ограничения пространства, доступного конкретной файловой системе или тому, может быть установлена квота.
Кроме того, возможно использование дискового резервирования (лимита) --- это гарантирует,
что всегда будет оставаться некоторый доступный объём для конкретной файловой системы или тома.

\section{Целостность данных}

Одна их главных особенностей ZFS, которая отличает ее от других файловых систем --- дизайн с упором на целостность данных.
ZFS защищает от скрытых повредлений данных, вызваных деградацией данных, перебоями в напряжении, ошибками в прошивке диска и некоректной записью.

В ZFS целостность данных достигается за счет использования контрольной суммы
на основе суммы Флетчера или SHA-256 по всему дереву файловой системы.
Для каждого блока данных вычисляется контрольная сумма,
которая затем сохраняется в указателе на этот блок, а не в самом блоке.
Затем контрольная сумма вычисляется и для самого указателя блока,
при этом значение сохраняется в указателе на него.
Этот процесс повторяется на всем пути вверх по иерархии данных файловой системы до корневого узла,
для которого также считается конторльная сумма, таким образом создавая дерево Меркла.

Повреждение данных во время передачи или при некорректной записи/чтении
не обнаруживаются большинством файловых систем, поскольку они хранят контрольную сумму вместе с данными.
ZFS хранит контрольную сумму каждого блока в указателе родительского блока,
поэтому весь пул проверяется автоматически.

При считывании любого блока подсчитывается его контрольная сумма,
которая сравнивается с контрольной суммой, хранящейся его указателе.
В случае расхождения ошибка сразу обнаруживается.
Разумеется, если в пуле заранее не было запланировано никакого резервирования, то ошибку уже не исправить, но зато испорченные данные не будут выданы за истинные.
Если же был предусмотрен какой-нибудь механизм избыточности, например зеркалирование диска,
то ZFS прочтет данные с него, и, в случае верности конторльной суммы,
не только вернет корректные данные но и восстановит поврежденные.

\section{RAID-Z}

Чтобы ZFS могла гарантировать целостность данных, ей необходимо несколько копий данных,
обычно распределенных по нескольким дискам.
Обычно это достигается с помощью либо RAID-контроллера,
либо так называемого <<soft RAID>> (встроенного в файловую систему).

Хотя ZFS может работать с аппаратными RAID-устройствами,
она работает более эффективно и с большей защитой данных,
если у нее есть непосредственный доступ ко всем устройствам хранения.
ZFS полагается на достоверность просмотра диска, чтобы определить момент,
когда данные подтверждаются как безопасно записанные, и имеет множество алгоритмов,
разработанных для оптимизации кэширования, очистки кэша и обработки диска.
Поэтому ZFS использует <<soft RAID>>, предлагая RAID-Z и зеркалирование дисков.

RAID-Z представляет собой схему распределения данных и четности, аналогичную RAID-5,
но использует динамическую ширину сектора: каждый блок представляет собой собственную сектор RAID,
независимо от размера, в результате чего каждая запись RAID-Z является записью полного сектора.
Это, в сочетании с семантикой транзакций копирования при записи ZFS, устраняет ошибку <<write hole error>>,
когда четность не соответствует данным из-за неатомарности процесса записи,
так что ее нельзя использовать для восстановления в случае сбоя диска.

Поскольку все секторы имеют разный размер,
при реконструкции RAID-Z необходимо просмотреть метаданные файловой системы,
чтобы определить фактическое расположение данных в RAID-Z.
Это было бы невозможно, если бы файловая система и RAID-массив были отдельными продуктами,
тогда как интегрированное представления логической и физической структуры данных для ZFS позволяет это сделать.
Прохождение через метаданные означает,
что ZFS может проверять каждый блок на соответствие его контрольной сумме,
в то время как традиционные продукты RAID обычно не могут этого делать.

\section{Копирование при записи}

Как уже упоминалось, ZFS использует механизм копирования при записи.
Блоки данных, содержащие активные в момент записи данные, никогда не перезаписываются;
напротив, выделяется новый блок, изменённые данные записываются в него,
а затем метаданные любых блоков, которые на него ссылаются,
таким образом всё перераспределяется и записывается.
Чтобы уменьшить накладные расходы, в этом процессе группируется несколько обновлений в группу транзакции,
также, если требуется, ведётся журнал использования при синхронной записи.

\section{Снимки и клоны}

Механизм копирования при записи в ZFS обладает ещё одним мощным преимуществом:
когда ZFS записывает новые данные --- вместо освобождения блоков,
содержащих старые данные --- она может сохранять их, создавая снимки файловой системы.
Они эффективно размещены в пространстве, поскольку одинаковые данные являются общими
между файловой системой и её снимком.

На основе любого снимка может быть создан перезаписываемый снимок (клон),
в результате чего будут существовать две или более независимые файловые системы или тома,
которые разделяют набор блоков для уменьшения общего занимаемого места.
Как только вносятся изменения в какой-либо клон файловой системы,
для него создаются блоки новых данных,
а во всех остальных клонах остаются прежние данные.

Снимки позволяют получать доступ к данным, которые были в хранилище в момент создания снимка,
или вернуть состояние хранилища к тому моменту.

Снимки и клоны могут создаваться рекурсивно для дерева файловых систем.
Это позволяет избежать необходимости многократного повторения команд
и самостоятельного управления транзакциями,
так как рекурсивное создание снимков атомарно.

\section{Другие особенности}

\subsection{Различный размер блока}

ZFS может использовать переменный размер блоков до 1 МБ.
Если блок был сжат, он может влиться в блок меньшего размера,
то есть используется меньшее пространство на диске и повышается пропускная способность
ценой расширенного использования процессора и оперативной памяти для операций компрессии и декомпрессии.

Пул ZFS также поддерживает различные размеры секторов устройств
и автоматически выбирает наибольший размер блока из устройств, указанных при создании пула.
Стабильно поддерживаются размеры 512 байт и 4 килобайта.
Поддерживаются и блоки больших размеров, но ОС при этом может работать не стабильно.

\subsection{Адаптивный порядок байт}

Массивы и настроенная на них ZFS могут быть перенесены между разными платформами,
даже если те имеют другой порядок байтов.
Формат блоков ZFS позволяет автоматически определять и менять порядок байтов на лету при чтении метаданных.

При этом разный порядок байтов на разных системах никак не отражается на приложениях,
файлы для них так и остаются простой последовательностью байтов.

\newpage

\section{Список литературы}

% Print bibliography without heading
\printbibliography [heading=none]


\end{document}
